<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/dcs-notes.github.io/assets/js/tocNav.js"></script>

    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/dcs-notes.github.io/assets/css/style.css">
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            <h1 class="project-name">Graphs</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#graphs-as-a-mathematical-concept">Graphs as a mathematical concept</a><ul><li><a href="#graph-properties">Graph properties</a></li></ul></li><li><a href="#graphs-as-an-adt">Graphs as an ADT</a><ul><li><a href="#concrete-implementations">Concrete Implementations</a><ul><li><a href="#edge-list-structure">Edge List Structure</a></li><li><a href="#adjacency-list">Adjacency list</a></li><li><a href="#adjacency-matrix">Adjacency matrix</a></li></ul></li></ul></li><li><a href="#subgraphs">Subgraphs</a></li><li><a href="#depth-first-search">Depth-first search</a><ul><li><a href="#uses-cases">Uses Cases</a></li></ul></li><li><a href="#breadth-first-search">Breadth-first search</a><ul><li><a href="#applications">Applications</a></li><li><a href="#dfs-and-bfs-visualization">DFS and BFS visualization</a></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/dcs-notes.github.io/CS126/part10.html" title="Binary Search & Self-Balancing Trees">üëàPrev</a><a href="./" title="CS126 Home">üè°CS126</a><a href="/dcs-notes.github.io/CS126/digraphs.html" title="Directed Graphs">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h2 id="graphs-as-a-mathematical-concept">Graphs as a mathematical concept</h2>

<p><strong>Graphs</strong> are defined as a pair \(G = (V, E)\) were \(V\) is a set of vertices, and \(E\) is an unordered collection of pairs of vertices, called edges, for example: \(G = (\{a, b, c\}, [(a,b), (b,c), (c,a)])\)</p>

<p>Directed and undirected graphs</p>
<ul>
  <li>
    <p>In undirected graphs, the edge pair indicates that both vertices are connected to each other</p>
  </li>
  <li>
    <p>In directed graphs, the edge pair indicates that the first vertex is connected to the second, but not vice versa</p>
  </li>
</ul>

<table class="centeredtable">
  <thead>
    <tr>
      <th>Term</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Adjacent Vertices</td>
      <td>Vertices with an edge between them</td>
    </tr>
    <tr>
      <td>Edges incident on a vertex</td>
      <td>Edges which both connect to the same vertex</td>
    </tr>
    <tr>
      <td>End vertices/endpoints</td>
      <td>The two vertices in the pair that an edge connects to</td>
    </tr>
    <tr>
      <td>Degree of a vertex</td>
      <td>The number of edges that connect to a pair</td>
    </tr>
    <tr>
      <td>Parallel edges</td>
      <td>Two edges both connecting the same nodes (This is the reason why edges are an unordered collection, not a <strong>set</strong>)</td>
    </tr>
    <tr>
      <td>Self-loop</td>
      <td>An edge whose vertices are both the same</td>
    </tr>
    <tr>
      <td>Path</td>
      <td>A sequence of alternating vertices and edges, starting and ending in a vertex</td>
    </tr>
    <tr>
      <td>Simple paths</td>
      <td>Paths containing no repeating vertices (hence are acyclic)</td>
    </tr>
    <tr>
      <td>Cycle</td>
      <td>A path starting and ending at the same vertex</td>
    </tr>
    <tr>
      <td>Acyclic</td>
      <td>A graph containing no cycles</td>
    </tr>
    <tr>
      <td>Simple cycle</td>
      <td>A path where the only repeated vertex is the starting/ending one</td>
    </tr>
    <tr>
      <td>Length (of a path of cycle)</td>
      <td>The number of edges in the path/cycle</td>
    </tr>
    <tr>
      <td>Tree</td>
      <td>A connected acyclic graph</td>
    </tr>
  </tbody>
</table>

<h3 id="graph-properties">Graph properties</h3>

<blockquote>
  <p><strong>Property 1.</strong> The <strong>sum of the degrees</strong> of the vertices in an undirected graph is an even number.</p>

  <p><strong>Proof. Handshaking Theorem.</strong> Every edge must connect two vertices, so sum of degrees is twice the number of edges, which must be even.</p>
</blockquote>

<blockquote>
  <p><strong>Property 2.</strong> An undirected graph with no self loops nor parallel edges, with number of edges \(m\) and number of vertices \(n\) fulfils the property \(m \leq \frac{n \cdot (n-1)}{2}\)</p>

  <p><strong>Proof.</strong> The first vertex can connect to \(n-1\) vertices (all vertices bar itself), then the second can connect to \(n-2\) (all the vertices bar itself and the first vertex, which it is already connected to), and so on, giving the sum \(1+2+...+n\) , which is known to be \(\frac{n \cdot (n-1)}{2}\)</p>

  <p>Fully connected graphs fulfil the property \(m = \frac{n \cdot (n-1)}{2}\)</p>
</blockquote>

<h2 id="graphs-as-an-adt">Graphs as an ADT</h2>

<blockquote>
  <p><strong>Graphs</strong> are a ‚Äúcollection of vertex and edge objects‚Äù</p>
</blockquote>

<p>They have a large number of fundamental operations, to the extent it is unnecessary to enumerate them here, but they are essentially just accessor, mutator, and count methods on the vertices and edges</p>

<h3 id="concrete-implementations">Concrete Implementations</h3>

<h4 id="edge-list-structure">Edge List Structure</h4>

<p>Consists of</p>

<ul>
  <li>
    <p>1 list of vertices</p>
  </li>
  <li>
    <p>1 list of edges, each of which contain references to their endpoint vertices</p>
  </li>
</ul>

<p><img src="images\edgeListGraph.png" alt="edgeListGraph" class="center" /></p>

<h4 id="adjacency-list">Adjacency list</h4>

<p>Consists of</p>

<ul>
  <li>1 list containing all of the vertices. Each of which have a pointer to a list edge objects of incident edges.</li>
</ul>

<p><img src="./images/adjacencyListGraph.png" alt="adjacencyListGraph" class="center" /></p>

<h4 id="adjacency-matrix">Adjacency matrix</h4>

<p>Consists of</p>

<ul>
  <li>2D array acts a lookup table for whether vertices have an edge connecting them</li>
  <li>Square matrix, with each dimension being the number of vertices in the graph</li>
  <li>Undirected graphs are symmetrical along the leading diagonal</li>
</ul>

<p><img src="./images/adjacencyMatrixGraph.png" alt="adjacencyMatrixGraph" class="center" /></p>

<h2 id="subgraphs">Subgraphs</h2>

<blockquote>
  <p>A <strong>subgraph</strong> of the graph \(G\) fulfils the two properties:</p>

  <ul>
    <li>
      <p>Its vertices are a subset of the vertices of \(G\)</p>
    </li>
    <li>
      <p>Its edges are a subset of the edges of \(G\)</p>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>A <strong>spanning subgraph</strong> contains all of the vertices in \(G\). This then gives rise to <strong>spanning trees</strong>, which are spanning subgraphs which are connected and acyclic.</p>

  <ul>
    <li>A spanning tree is not unique unless the graph is a tree.</li>
  </ul>
</blockquote>

<h2 id="depth-first-search">Depth-first search</h2>

<blockquote>
  <p>Depth-first search is a general technique for traverse graphs. It takes \(O(n + m)\) time to search a graph of \(n\) vertices and \(m\) edges.</p>
</blockquote>

<p>Informally, it can be described as always proceeding to its first adjacency, then backtracking when it reaches a vertex with no adjacencies which it has not explored already</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">):</span>
  <span class="nl">Input:</span> <span class="no">A</span> <span class="n">graph</span> <span class="no">G</span> <span class="n">and</span> <span class="n">a</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">of</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">of</span> <span class="no">G</span> <span class="n">in</span> <span class="n">the</span> <span class="n">connected</span> <span class="n">component</span> <span class="n">of</span> <span class="n">v</span> <span class="n">as</span> <span class="n">discovery</span> <span class="n">edges</span> <span class="n">and</span> <span class="n">back</span> <span class="n">edges</span>
    <span class="nf">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
      <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
        <span class="c1">// Get vertex w, that's opposite vertex v across edge e</span>
        <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
        <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
          <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"discovery"</span><span class="o">)</span>
          <span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
        <span class="k">else</span>
          <span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"back"</span><span class="o">)</span>
</code></pre></div></div>

<blockquote>
  <p>It has the following properties</p>

  <ul>
    <li>It visits all vertices and edges in any connected component of a graph</li>
    <li>The discovery edges form a spanning tree of any graph it traverses</li>
  </ul>
</blockquote>

<h3 id="uses-cases">Uses Cases</h3>

<p>It can be used for <strong>path-finding</strong> by performing the traversal until the target node is found, then <strong>backtracking</strong> along the <strong>discovery edges</strong> to find the reverse of the path.</p>

<ul>
  <li>This is done by altering the DFS algorithm to push <strong>visited</strong> vertices and <strong>discovery</strong> edges as the algorithm goes through them.</li>
  <li>Once the target vertex is found, we return the path as the contents of the stack</li>
</ul>

<p>It can be used to <strong>identify cycles</strong>, as if it <strong>ever finds</strong> an <strong>adjacency</strong> to a vertex which it has <strong>already explored</strong>, (a <strong>back edge</strong>), the graph must contain a cycle.</p>

<ul>
  <li>A stack is again used for the same purpose.</li>
  <li>When a <strong>back edge</strong> is encountered between a node <strong><em>v</em></strong> and another node <strong><em>w</em></strong>, the cycle is returned as the <strong>portion of the stack</strong> from the top to until node <strong><em>v</em></strong>.is</li>
</ul>

<h2 id="breadth-first-search">Breadth-first search</h2>

<blockquote>
  <p>Breadth-first search is a technique to traverse graphs. It takes \(O(n + m)\) time to search a graph of \(n\) vertices and \(m\) edges.</p>
</blockquote>

<p>Informally, it can be described as exploring every one of its adjacencies, then proceeding to the first adjacency, then backtracking when it reaches a vertex with no adjacencies which it has not explored already</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
  <span class="nl">Input:</span> <span class="n">graph</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">and</span> <span class="n">partition</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="no">G</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">u</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">edges</span><span class="o">()</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span>
      <span class="no">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<blockquote>
  <p>It has the following properties</p>

  <ul>
    <li>It <strong>visits all</strong> vertices and edges in \(G_s\), the connected component of a graph \(s\)</li>
    <li>The <strong>discovery edges</strong> form a <strong>spanning tree</strong> of any graph it traverses</li>
    <li>The <strong>path</strong> between any two vertices in the spanning tree of <strong>discovery edges</strong> it creates is the <strong>shortest path</strong> between them in the graph</li>
  </ul>
</blockquote>

<p>It can be used for path-finding by performing the traversal until the target node is found, then backtracking along the discovery edges to find the reverse of the path.</p>

<p>It can be used to identify cycles, as if it ever finds an adjacency to a vertex which it has already explored, (a back edge), the graph must contain a cycle.</p>

<h3 id="applications">Applications</h3>

<p>We can specialise the BFS algorithm to solve the following problems in \(O(n+m)\) time.</p>

<ul>
  <li>Compute the connected components of G</li>
  <li>Compute a spanning forest of G</li>
  <li>Find a simple cycle in G, or report that G is a forest</li>
  <li>Given two vertices of G, find a path in G between them with the minimum number of edges, or report that no such path exists.</li>
</ul>

<h3 id="dfs-and-bfs-visualization">DFS and BFS visualization</h3>

<p>The site linked <a href="https://www.cs.usfca.edu/~galles/visualization/DFS.html">here</a> traces the steps of DFS either or BFS, and one can specify whether each node is connected, as well as whether the graphs are directed or undirected</p>


                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>